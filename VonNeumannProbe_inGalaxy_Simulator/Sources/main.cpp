// Code generated by GitHub Copilot.

#include <vector>
#include <random>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>
#include "Engine/Core/Modules/Stellar/StellarClass.h"
#include "Engine/Core/Logger.h"

std::atomic<bool> timeoutOccurred(false);
std::string lastScAttempted; // 用于存储最后尝试解析的sc字符串

void ParseWrapper(const std::string& sc) {
    auto start = std::chrono::high_resolution_clock::now();
    Npgs::Modules::StellarClass::Parse(sc);
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end - start;
    if (elapsed.count() > 0.1) {
        Npgs::Logger::GetClientLogger()->warn("Timeout occurred for spectral type: {}", sc);
        timeoutOccurred = true;
    } else {
        Npgs::Logger::GetClientLogger()->info("Parsed successfully: {}", sc);
    }
}

std::string GenerateRandomSpectralTypeStr(std::mt19937& gen) {
    //std::random_device rd;
    //std::mt19937 gen(rd());


    // 分类为普通恒星、白矮星、WR星、中子星和黑洞的光谱类别
    const char* normalSpectralClasses[] = { "O", "B", "A", "F", "G", "K", "M" };
    const char* whiteDwarfSpectralClasses[] = { "DA", "DB", "DC", "DO", "DQ", "DZ" };
    const char* wrSpectralClasses[] = { "WC", "WN", "WO" };
    const char* neutronStarAndBlackHoleClasses[] = { "Q", "X" };

    // 亮度类别数组
    const char* luminosityClasses[] = { "Ia+", "Ia", "Iab", "Ib", "I", "II", "III", "IV", "V", "VI" };

    std::uniform_int_distribution<> typeDist(0, 3); // 选择恒星类型
    int type = typeDist(gen);

    std::string spectralTypeStr;
    std::uniform_int_distribution<> subclassDist(0, 9);

    switch (type) {
    case 0: // 普通恒星
    {
        std::uniform_int_distribution<> spectralClassDist(0, sizeof(normalSpectralClasses) / sizeof(normalSpectralClasses[0]) - 1);
        std::uniform_int_distribution<> luminosityClassDist(0, sizeof(luminosityClasses) / sizeof(luminosityClasses[0]) - 1);
        spectralTypeStr = normalSpectralClasses[spectralClassDist(gen)] + std::to_string(subclassDist(gen)) + " " + luminosityClasses[luminosityClassDist(gen)];
        break;
    }
    case 1: // 白矮星
    {
        std::uniform_int_distribution<> spectralClassDist(0, sizeof(whiteDwarfSpectralClasses) / sizeof(whiteDwarfSpectralClasses[0]) - 1);
        spectralTypeStr = whiteDwarfSpectralClasses[spectralClassDist(gen)] + std::to_string(subclassDist(gen));
        break;
    }
    case 2: // WR星
    {
        std::uniform_int_distribution<> spectralClassDist(0, sizeof(wrSpectralClasses) / sizeof(wrSpectralClasses[0]) - 1);
        spectralTypeStr = wrSpectralClasses[spectralClassDist(gen)];
        break;
    }
    case 3: // 中子星或黑洞
    {
        std::uniform_int_distribution<> spectralClassDist(0, sizeof(neutronStarAndBlackHoleClasses) / sizeof(neutronStarAndBlackHoleClasses[0]) - 1);
        spectralTypeStr = neutronStarAndBlackHoleClasses[spectralClassDist(gen)];
        break;
    }
    }

    // 随机决定是否添加特殊标记
    std::uniform_int_distribution<> markDecisionDist(0, 4); // 0-3为特殊标记，4表示不添加
    int markDecision = markDecisionDist(gen);

    if (markDecision < 4) { // 添加特殊标记
        switch (markDecision) {
        case 0: // 'f' 标记
            spectralTypeStr += "f";
            break;
        case 1: // 'h' 标记
            spectralTypeStr += "h";
            break;
        case 2: // 'm' 标记，需要特殊处理
            if (type == 0) { // 仅对普通恒星应用
                std::uniform_int_distribution<> subclassDist2(0, 9);
                spectralTypeStr = spectralTypeStr.substr(0, spectralTypeStr.size() - 2) + "m" + spectralTypeStr.substr(spectralTypeStr.size() - 2) + std::to_string(subclassDist2(gen)) + "V";
            }
            break;
        case 3: // 'p' 标记
            spectralTypeStr += "p";
            break;
        }
    }
    // 如果markDecision为4，则不添加特殊标记，保持spectralTypeStr不变

    return spectralTypeStr;
}

int main() {
    Npgs::Logger::Init();

    const int totalCases = 160;
    std::vector<std::string> globalSpectralTypes;

    auto cpuCount = std::thread::hardware_concurrency();
    std::vector<std::thread> threads;
    std::vector<std::vector<std::string>> localSpectralTypes(cpuCount);

    auto generateFunc = [&](int threadIndex) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::vector<std::string>& localVec = localSpectralTypes[threadIndex];
        int casesPerThread = totalCases / cpuCount;

        for (int i = 0; i < casesPerThread; ++i) {
            localVec.push_back(GenerateRandomSpectralTypeStr(gen));
        }
    };

    // 启动多线程生成测试用例
    for (unsigned i = 0; i < cpuCount; ++i) {
        threads.emplace_back(generateFunc, i);
    }

    for (auto& t : threads) {
        t.join();
    }

    // 合并局部向量到全局向量
    for (const auto& localVec : localSpectralTypes) {
        globalSpectralTypes.insert(globalSpectralTypes.end(), localVec.begin(), localVec.end());
    }

    std::cout << "Generate complete. Generated " << globalSpectralTypes.size() << " spectral types." << std::endl;

    // 单线程解析测试用例
    auto start = std::chrono::high_resolution_clock::now();
    int timeoutCount = 0;
    for (const auto& sc : globalSpectralTypes) {
        ParseWrapper(sc);
    }
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end - start; // 将时间间隔转换为毫秒
    std::cout << "Parsing completed in " << elapsed.count() << " milliseconds." << std::endl;
    std::cout << "Timeout cases: " << timeoutCount << std::endl;

    //Npgs::Modules::StellarClass sc = Npgs::Modules::StellarClass::Parse("WN5h");
    //std::bitset<64> Bin(sc.Data());
    //std::cout << Bin << std::endl;

    return 0;
}
